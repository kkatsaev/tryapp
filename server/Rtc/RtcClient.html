<!DOCTYPE html>
<head>
    <title>RtcClient (sample)</title>
    <meta charset="UTF-8">

    <script type="text/javascript">
        //const DATA_CHANNEL_LABEL = "dc1";

        const id = Date.now().toString();
        const baseUrl = "http://localhost:5270/api/"; //"api/webrtc/";
        const getOfferUrl = `${baseUrl}getoffer?id=${id}`;
        const setAnswerUrl = `${baseUrl}setanswer?id=${id}`;
        //const setIceCandidateUrl = `${baseUrl}addicecandidate?id=${id}`

        let pc;//, dc;

        async function startConnection() {
            console.log(">>>> startConnection");
            console.log("getting offer: " + getOfferUrl);
            let offerResponse = await fetch(getOfferUrl);
            let offer = await offerResponse.json();
            console.log("result offer: ", offer);

            console.log("creating peer connection and assigning remote description");
            //const STUN_URL = "stun:stun.sipsorcery.com";
            //pc = new RTCPeerConnection({ iceServers: [{ urls: STUN_URL }] });
            pc = new RTCPeerConnection();
            
            pc.onconnectionstatechange = () => {
                console.log("onconnectionstatechange: " + pc.connectionState);
            }
            
            setupDataChannel(pc);

            pc.onicegatheringstatechange = function () {
                console.log("onicegatheringstatechange: " + pc.iceGatheringState);
            }
            pc.oniceconnectionstatechange = function () {
                console.log("oniceconnectionstatechange: " + pc.iceConnectionState);
            }
            pc.onsignalingstatechange = function () {
                console.log("onsignalingstatechange: " + pc.signalingState);
            }
            pc.onicecandidate = async function (event) {
                console.log('onicecandidate: ', event.candidate);
                if (event.candidate) {
                    //TODO: send candidates to server
                    // await fetch(setIceCandidateUrl, {
                    //     method: 'POST',
                    //     body: JSON.stringify(event.candidate),
                    //     headers: { 'Content-Type': 'application/json' }
                    // });
                }
            };
            pc.onicecandidateerror = function (event) {
                console.log("onicecandidateerror: " + JSON.stringify(event));
            }

            await pc.setRemoteDescription(offer);

            console.log("creating answer");
            let answer = await pc.createAnswer();
            console.log("assigning answer as local description: ", answer);
            await pc.setLocalDescription(answer);

            console.log("posting answer: " + setAnswerUrl);
            let answerResponse = await fetch(setAnswerUrl, {
                method: 'POST',
                body: JSON.stringify(answer),
                headers: { 'Content-Type': 'application/json' }
            });
            let candidate = new RTCIceCandidate(await answerResponse.json());
            console.log("result of answer (ice candidate): ", candidate);
            await pc.addIceCandidate(candidate);
            console.log("<<<< startConnection");
        }

        function setupDataChannel(pc) {
            let messagesOk = 0
            let messagesLost = 0
            let messagesLate = 0
            let messagesOkElement = document.getElementById('ok')
            let messagesLostElement = document.getElementById('lost')
            let messagesLateElement = document.getElementById('late')
            let lastMessageId = 0
            let firstMessage = true
            
            pc.ondatachannel = (event) => {
                const channel = event.channel
                console.log("ondatachannel: ", channel);
                channel.onmessage = function (event) {
                    console.log('DataChannel: onmessage:', event.data); //`message type ${event.type}, label ${event.target.label}, data ${event.data}.`);
                    // if (event.data instanceof ArrayBuffer) {
                    //     console.log(`binary data of length ${event.data.byteLength}.`);
                    //     event.target.send(event.data);
                    // }
                    // Ideally this wouldn't be a string, but that's out of scope here.

                    const messageId = parseInt(event.data.split(";")[0], 10)

                    if (messageId <= lastMessageId) {
                        // This message is old. We can either skip it, or handle it
                        // differently knowing it is old.
                        if (messageId < lastMessageId) {
                            messagesLost--
                            messagesLate++
                        }
                    } else {
                        messagesOk++
                    }

                    if (messageId > lastMessageId + 1) {
                        if (firstMessage) {
                            firstMessage = false
                        } else {
                            // Some messages before this one are late or were lost. 
                            // If this happens a lot we may want to alert the user that the
                            // connection seems unstable.
                            messagesLost += messageId - lastMessageId - 1
                        }
                    }
                    lastMessageId = messageId

                    messagesOkElement.innerText = messagesOk
                    messagesLostElement.innerText = messagesLost
                    messagesLateElement.innerText = messagesLate
                }

                console.log(`DataChannel: timer: starting to send data`);
                let frameId = 1;
                let timer = setInterval(() => {
                    const readyState = channel.readyState;
                    if (readyState !== "open") {
                        console.log(`DataChannel: timer: stop: readyState=${readyState}`);
                        clearInterval(timer);
                        return;
                    }
                    const connectionState = pc.connectionState;
                    if (connectionState !== "connected") {
                        console.log(`DataChannel: timer: stop: connectionState=${connectionState}`);
                        clearInterval(timer);
                        return;
                    }
                    const message = frameId + ";TODO-FROM-CLIENT;" + Date.now();
                    console.log(`DataChannel: make send: ${message}`);
                    channel.send(message);
                    frameId++;
                }, 1000); // every second
            }

            //dc = pc.createDataChannel(DATA_CHANNEL_LABEL);
        }
        
        async function closeConnection() {
            console.log("======== closeConnection ========");
            await pc?.close();
        }
    </script>
</head>
<body>
<h1>RtcClient (sample)</h1>

<div>
<!--    <input type="checkbox" id="makeoffer" name="makfeoffer" value="makeoffer" onchange="seturl();"> Make Offer-->
<!--    <input type="text" id="websockurl" size="40"/>-->
    <button type="button" class="btn btn-success" onclick="startConnection();">Open</button>
    <button type="button" class="btn btn-success" onclick="closeConnection();">Close</button>
</div>

<h2>Result</h2>

<div>Messages OK: <span id="ok">0</span></div>
<div>Messages Lost: <span id="lost">0</span></div>
<div>Messages Late: <span id="late">0</span></div>

<!--<div>-->
<!--    <input type="text" id="message" value="hello world"/>-->
<!--    <button type="button" class="btn btn-success" onclick="sendMessage(document.querySelector('#message').value);">Send-->
<!--        Message-->
<!--    </button>-->
<!--</div>-->

<!--<div>-->
<!--    <input type="text" id="rndByteLength"/>-->
<!--    <button type="button" class="btn btn-success" onclick="sendRandomEcho();">Send Random Echo</button>-->
<!--</div>-->
</body>
